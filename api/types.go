// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type BaseEvent struct {
	Id        string      `json:"id"`
	Timestamp string      `json:"timestamp"`
	Metadata  interface{} `json:"metadata,omitempty"`
}

type CreateEventBody struct {
	TraceId             *string           `json:"traceId,omitempty"`
	Name                *string           `json:"name,omitempty"`
	StartTime           *time.Time        `json:"startTime,omitempty"`
	Metadata            *interface{}      `json:"metadata,omitempty"`
	Input               *interface{}      `json:"input,omitempty"`
	Output              *interface{}      `json:"output,omitempty"`
	Level               *ObservationLevel `json:"level,omitempty"`
	StatusMessage       *string           `json:"statusMessage,omitempty"`
	ParentObservationId *string           `json:"parentObservationId,omitempty"`
	Version             *string           `json:"version,omitempty"`
	Id                  *string           `json:"id,omitempty"`
}

type CreateEventEvent struct {
	Id        string           `json:"id"`
	Timestamp string           `json:"timestamp"`
	Metadata  interface{}      `json:"metadata,omitempty"`
	Body      *CreateEventBody `json:"body,omitempty"`
}

type CreateGenerationBody struct {
	TraceId             *string              `json:"traceId,omitempty"`
	Name                *string              `json:"name,omitempty"`
	StartTime           *time.Time           `json:"startTime,omitempty"`
	Metadata            *interface{}         `json:"metadata,omitempty"`
	Input               *interface{}         `json:"input,omitempty"`
	Output              *interface{}         `json:"output,omitempty"`
	Level               *ObservationLevel    `json:"level,omitempty"`
	StatusMessage       *string              `json:"statusMessage,omitempty"`
	ParentObservationId *string              `json:"parentObservationId,omitempty"`
	Version             *string              `json:"version,omitempty"`
	Id                  *string              `json:"id,omitempty"`
	EndTime             *time.Time           `json:"endTime,omitempty"`
	CompletionStartTime *time.Time           `json:"completionStartTime,omitempty"`
	Model               *string              `json:"model,omitempty"`
	ModelParameters     map[string]*MapValue `json:"modelParameters,omitempty"`
	Usage               *IngestionUsage      `json:"usage,omitempty"`
	PromptName          *string              `json:"promptName,omitempty"`
	PromptVersion       *int                 `json:"promptVersion,omitempty"`
}

type CreateGenerationEvent struct {
	Id        string                `json:"id"`
	Timestamp string                `json:"timestamp"`
	Metadata  interface{}           `json:"metadata,omitempty"`
	Body      *CreateGenerationBody `json:"body,omitempty"`
}

type CreateObservationEvent struct {
	Id        string           `json:"id"`
	Timestamp string           `json:"timestamp"`
	Metadata  interface{}      `json:"metadata,omitempty"`
	Body      *ObservationBody `json:"body,omitempty"`
}

type CreateSpanBody struct {
	TraceId             *string           `json:"traceId,omitempty"`
	Name                *string           `json:"name,omitempty"`
	StartTime           *time.Time        `json:"startTime,omitempty"`
	Metadata            *interface{}      `json:"metadata,omitempty"`
	Input               *interface{}      `json:"input,omitempty"`
	Output              *interface{}      `json:"output,omitempty"`
	Level               *ObservationLevel `json:"level,omitempty"`
	StatusMessage       *string           `json:"statusMessage,omitempty"`
	ParentObservationId *string           `json:"parentObservationId,omitempty"`
	Version             *string           `json:"version,omitempty"`
	Id                  *string           `json:"id,omitempty"`
	EndTime             *time.Time        `json:"endTime,omitempty"`
}

type CreateSpanEvent struct {
	Id        string          `json:"id"`
	Timestamp string          `json:"timestamp"`
	Metadata  interface{}     `json:"metadata,omitempty"`
	Body      *CreateSpanBody `json:"body,omitempty"`
}

type Dataset struct {
	Id        string         `json:"id"`
	Name      string         `json:"name"`
	ProjectId string         `json:"projectId"`
	CreatedAt time.Time      `json:"createdAt"`
	UpdatedAt time.Time      `json:"updatedAt"`
	Items     []*DatasetItem `json:"items,omitempty"`
	Runs      []string       `json:"runs,omitempty"`
}

type DatasetItem struct {
	Id                  string        `json:"id"`
	Status              DatasetStatus `json:"status,omitempty"`
	Input               interface{}   `json:"input,omitempty"`
	ExpectedOutput      *interface{}  `json:"expectedOutput,omitempty"`
	SourceObservationId *string       `json:"sourceObservationId,omitempty"`
	DatasetId           string        `json:"datasetId"`
	CreatedAt           time.Time     `json:"createdAt"`
	UpdatedAt           time.Time     `json:"updatedAt"`
}

type DatasetRun struct {
	Id              string            `json:"id"`
	Name            string            `json:"name"`
	DatasetId       string            `json:"datasetId"`
	CreatedAt       time.Time         `json:"createdAt"`
	UpdatedAt       time.Time         `json:"updatedAt"`
	DatasetRunItems []*DatasetRunItem `json:"datasetRunItems,omitempty"`
}

type DatasetRunItem struct {
	Id            string    `json:"id"`
	DatasetRunId  string    `json:"datasetRunId"`
	DatasetItemId string    `json:"datasetItemId"`
	ObservationId string    `json:"observationId"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

type DatasetStatus string

const (
	DatasetStatusActive   DatasetStatus = "ACTIVE"
	DatasetStatusArchived DatasetStatus = "ARCHIVED"
)

func NewDatasetStatusFromString(s string) (DatasetStatus, error) {
	switch s {
	case "ACTIVE":
		return DatasetStatusActive, nil
	case "ARCHIVED":
		return DatasetStatusArchived, nil
	}
	var t DatasetStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatasetStatus) Ptr() *DatasetStatus {
	return &d
}

type HealthResponse struct {
	// Langfuse server version
	Version string `json:"version"`
	Status  string `json:"status"`
}

type IngestionError struct {
	Id      string       `json:"id"`
	Status  int          `json:"status"`
	Message *string      `json:"message,omitempty"`
	Error   *interface{} `json:"error,omitempty"`
}

type IngestionEvent struct {
	Type      string                 `json:"type"`
	Body      interface{}            `json:"body"`
	ID        string                 `json:"id"`
	Metadata  map[string]interface{} `json:"metadata"`
	Timestamp time.Time              `json:"timestamp"`
}

type IngestionResponse struct {
	Successes []*IngestionSuccess `json:"successes,omitempty"`
	Errors    []*IngestionError   `json:"errors,omitempty"`
}

type IngestionSuccess struct {
	Id     string `json:"id"`
	Status int    `json:"status"`
}

type IngestionUsage struct {
	typeName    string
	Usage       *Usage
	OpenAiUsage *OpenAiUsage
}

func NewIngestionUsageFromUsage(value *Usage) *IngestionUsage {
	return &IngestionUsage{typeName: "usage", Usage: value}
}

func NewIngestionUsageFromOpenAiUsage(value *OpenAiUsage) *IngestionUsage {
	return &IngestionUsage{typeName: "openAiUsage", OpenAiUsage: value}
}

func (i *IngestionUsage) UnmarshalJSON(data []byte) error {
	valueUsage := new(Usage)
	if err := json.Unmarshal(data, &valueUsage); err == nil {
		i.typeName = "usage"
		i.Usage = valueUsage
		return nil
	}
	valueOpenAiUsage := new(OpenAiUsage)
	if err := json.Unmarshal(data, &valueOpenAiUsage); err == nil {
		i.typeName = "openAiUsage"
		i.OpenAiUsage = valueOpenAiUsage
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IngestionUsage) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "usage":
		return json.Marshal(i.Usage)
	case "openAiUsage":
		return json.Marshal(i.OpenAiUsage)
	}
}

type IngestionUsageVisitor interface {
	VisitUsage(*Usage) error
	VisitOpenAiUsage(*OpenAiUsage) error
}

func (i *IngestionUsage) Accept(visitor IngestionUsageVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "usage":
		return visitor.VisitUsage(i.Usage)
	case "openAiUsage":
		return visitor.VisitOpenAiUsage(i.OpenAiUsage)
	}
}

type MapValue struct {
	typeName        string
	StringOptional  *string
	IntegerOptional *int
	BooleanOptional *bool
}

func NewMapValueFromStringOptional(value *string) *MapValue {
	return &MapValue{typeName: "stringOptional", StringOptional: value}
}

func NewMapValueFromIntegerOptional(value *int) *MapValue {
	return &MapValue{typeName: "integerOptional", IntegerOptional: value}
}

func NewMapValueFromBooleanOptional(value *bool) *MapValue {
	return &MapValue{typeName: "booleanOptional", BooleanOptional: value}
}

func (m *MapValue) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		m.typeName = "stringOptional"
		m.StringOptional = valueStringOptional
		return nil
	}
	var valueIntegerOptional *int
	if err := json.Unmarshal(data, &valueIntegerOptional); err == nil {
		m.typeName = "integerOptional"
		m.IntegerOptional = valueIntegerOptional
		return nil
	}
	var valueBooleanOptional *bool
	if err := json.Unmarshal(data, &valueBooleanOptional); err == nil {
		m.typeName = "booleanOptional"
		m.BooleanOptional = valueBooleanOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MapValue) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "stringOptional":
		return json.Marshal(m.StringOptional)
	case "integerOptional":
		return json.Marshal(m.IntegerOptional)
	case "booleanOptional":
		return json.Marshal(m.BooleanOptional)
	}
}

type MapValueVisitor interface {
	VisitStringOptional(*string) error
	VisitIntegerOptional(*int) error
	VisitBooleanOptional(*bool) error
}

func (m *MapValue) Accept(visitor MapValueVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "stringOptional":
		return visitor.VisitStringOptional(m.StringOptional)
	case "integerOptional":
		return visitor.VisitIntegerOptional(m.IntegerOptional)
	case "booleanOptional":
		return visitor.VisitBooleanOptional(m.BooleanOptional)
	}
}

type ModelUsageUnit string

const (
	ModelUsageUnitCharacters ModelUsageUnit = "CHARACTERS"
	ModelUsageUnitTokens     ModelUsageUnit = "TOKENS"
)

func NewModelUsageUnitFromString(s string) (ModelUsageUnit, error) {
	switch s {
	case "CHARACTERS":
		return ModelUsageUnitCharacters, nil
	case "TOKENS":
		return ModelUsageUnitTokens, nil
	}
	var t ModelUsageUnit
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ModelUsageUnit) Ptr() *ModelUsageUnit {
	return &m
}

type Observation struct {
	Id                  string               `json:"id"`
	TraceId             *string              `json:"traceId,omitempty"`
	Type                string               `json:"type"`
	Name                *string              `json:"name,omitempty"`
	StartTime           time.Time            `json:"startTime"`
	EndTime             *time.Time           `json:"endTime,omitempty"`
	CompletionStartTime *time.Time           `json:"completionStartTime,omitempty"`
	Model               *string              `json:"model,omitempty"`
	ModelParameters     map[string]*MapValue `json:"modelParameters,omitempty"`
	Input               *interface{}         `json:"input,omitempty"`
	Version             *string              `json:"version,omitempty"`
	Metadata            *interface{}         `json:"metadata,omitempty"`
	Output              *interface{}         `json:"output,omitempty"`
	Usage               *Usage               `json:"usage,omitempty"`
	Level               ObservationLevel     `json:"level,omitempty"`
	StatusMessage       *string              `json:"statusMessage,omitempty"`
	ParentObservationId *string              `json:"parentObservationId,omitempty"`
	PromptId            *string              `json:"promptId,omitempty"`
}

type ObservationBody struct {
	Id                  *string              `json:"id,omitempty"`
	TraceId             *string              `json:"traceId,omitempty"`
	Type                ObservationType      `json:"type,omitempty"`
	Name                *string              `json:"name,omitempty"`
	StartTime           *time.Time           `json:"startTime,omitempty"`
	EndTime             *time.Time           `json:"endTime,omitempty"`
	CompletionStartTime *time.Time           `json:"completionStartTime,omitempty"`
	Model               *string              `json:"model,omitempty"`
	ModelParameters     map[string]*MapValue `json:"modelParameters,omitempty"`
	Input               *interface{}         `json:"input,omitempty"`
	Version             *string              `json:"version,omitempty"`
	Metadata            *interface{}         `json:"metadata,omitempty"`
	Output              *interface{}         `json:"output,omitempty"`
	Usage               *Usage               `json:"usage,omitempty"`
	Level               *ObservationLevel    `json:"level,omitempty"`
	StatusMessage       *string              `json:"statusMessage,omitempty"`
	ParentObservationId *string              `json:"parentObservationId,omitempty"`
}

type ObservationLevel string

const (
	ObservationLevelDebug   ObservationLevel = "DEBUG"
	ObservationLevelDefault ObservationLevel = "DEFAULT"
	ObservationLevelWarning ObservationLevel = "WARNING"
	ObservationLevelError   ObservationLevel = "ERROR"
)

func NewObservationLevelFromString(s string) (ObservationLevel, error) {
	switch s {
	case "DEBUG":
		return ObservationLevelDebug, nil
	case "DEFAULT":
		return ObservationLevelDefault, nil
	case "WARNING":
		return ObservationLevelWarning, nil
	case "ERROR":
		return ObservationLevelError, nil
	}
	var t ObservationLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o ObservationLevel) Ptr() *ObservationLevel {
	return &o
}

type ObservationType string

const (
	ObservationTypeSpan       ObservationType = "SPAN"
	ObservationTypeGeneration ObservationType = "GENERATION"
	ObservationTypeEvent      ObservationType = "EVENT"
)

func NewObservationTypeFromString(s string) (ObservationType, error) {
	switch s {
	case "SPAN":
		return ObservationTypeSpan, nil
	case "GENERATION":
		return ObservationTypeGeneration, nil
	case "EVENT":
		return ObservationTypeEvent, nil
	}
	var t ObservationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o ObservationType) Ptr() *ObservationType {
	return &o
}

type Observations struct {
	Data []*Observation     `json:"data,omitempty"`
	Meta *UtilsMetaResponse `json:"meta,omitempty"`
}

type OpenAiUsage struct {
	PromptTokens     *int `json:"promptTokens,omitempty"`
	CompletionTokens *int `json:"completionTokens,omitempty"`
	TotalTokens      *int `json:"totalTokens,omitempty"`
}

type OptionalObservationBody struct {
	TraceId             *string           `json:"traceId,omitempty"`
	Name                *string           `json:"name,omitempty"`
	StartTime           *time.Time        `json:"startTime,omitempty"`
	Metadata            *interface{}      `json:"metadata,omitempty"`
	Input               *interface{}      `json:"input,omitempty"`
	Output              *interface{}      `json:"output,omitempty"`
	Level               *ObservationLevel `json:"level,omitempty"`
	StatusMessage       *string           `json:"statusMessage,omitempty"`
	ParentObservationId *string           `json:"parentObservationId,omitempty"`
	Version             *string           `json:"version,omitempty"`
}

type Project struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type Projects struct {
	Data []*Project `json:"data,omitempty"`
}

type Prompt struct {
	Name    string `json:"name"`
	Version int    `json:"version"`
	Prompt  string `json:"prompt"`
}

type Score struct {
	Id            string    `json:"id"`
	TraceId       string    `json:"traceId"`
	Name          string    `json:"name"`
	Value         float64   `json:"value"`
	ObservationId *string   `json:"observationId,omitempty"`
	Timestamp     time.Time `json:"timestamp"`
	Comment       *string   `json:"comment,omitempty"`
}

type ScoreBody struct {
	Id            *string `json:"id,omitempty"`
	TraceId       string  `json:"traceId"`
	Name          string  `json:"name"`
	Value         float64 `json:"value"`
	ObservationId *string `json:"observationId,omitempty"`
	Comment       *string `json:"comment,omitempty"`
}

type ScoreEvent struct {
	Id        string      `json:"id"`
	Timestamp string      `json:"timestamp"`
	Metadata  interface{} `json:"metadata,omitempty"`
	Body      *ScoreBody  `json:"body,omitempty"`
}

type Scores struct {
	Data []*Score           `json:"data,omitempty"`
	Meta *UtilsMetaResponse `json:"meta,omitempty"`
}

type SdkLogBody struct {
	Log interface{} `json:"log,omitempty"`
}

type SdkLogEvent struct {
	Id        string      `json:"id"`
	Timestamp string      `json:"timestamp"`
	Metadata  interface{} `json:"metadata,omitempty"`
	Body      *SdkLogBody `json:"body,omitempty"`
}

type Session struct {
	Id        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	ProjectId string    `json:"projectId"`
}

type SessionWithTraces struct {
	Id        string    `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	ProjectId string    `json:"projectId"`
	Traces    []*Trace  `json:"traces,omitempty"`
}

type Trace struct {
	// The unique identifier of a trace
	Id        string       `json:"id"`
	Timestamp time.Time    `json:"timestamp"`
	Name      *string      `json:"name,omitempty"`
	Input     *interface{} `json:"input,omitempty"`
	Output    *interface{} `json:"output,omitempty"`
	SessionId *string      `json:"sessionId,omitempty"`
	Release   *string      `json:"release,omitempty"`
	Version   *string      `json:"version,omitempty"`
	UserId    *string      `json:"userId,omitempty"`
	Metadata  *interface{} `json:"metadata,omitempty"`
	Tags      []string     `json:"tags,omitempty"`
	// Public traces are accessible via url without login
	Public *bool `json:"public,omitempty"`
}

type TraceBody struct {
	Id        *string      `json:"id,omitempty"`
	Name      *string      `json:"name,omitempty"`
	UserId    *string      `json:"userId,omitempty"`
	Input     *interface{} `json:"input,omitempty"`
	Output    *interface{} `json:"output,omitempty"`
	SessionId *string      `json:"sessionId,omitempty"`
	Release   *string      `json:"release,omitempty"`
	Version   *string      `json:"version,omitempty"`
	Metadata  *interface{} `json:"metadata,omitempty"`
	Tags      []string     `json:"tags,omitempty"`
	// Make trace publicly accessible via url
	Public *bool `json:"public,omitempty"`
}

type TraceEvent struct {
	Id        string      `json:"id"`
	Timestamp string      `json:"timestamp"`
	Metadata  interface{} `json:"metadata,omitempty"`
	Body      *TraceBody  `json:"body,omitempty"`
}

type TraceWithDetails struct {
	// The unique identifier of a trace
	Id        string       `json:"id"`
	Timestamp time.Time    `json:"timestamp"`
	Name      *string      `json:"name,omitempty"`
	Input     *interface{} `json:"input,omitempty"`
	Output    *interface{} `json:"output,omitempty"`
	SessionId *string      `json:"sessionId,omitempty"`
	Release   *string      `json:"release,omitempty"`
	Version   *string      `json:"version,omitempty"`
	UserId    *string      `json:"userId,omitempty"`
	Metadata  *interface{} `json:"metadata,omitempty"`
	Tags      []string     `json:"tags,omitempty"`
	// Public traces are accessible via url without login
	Public *bool `json:"public,omitempty"`
	// List of observation ids
	Observations []string `json:"observations,omitempty"`
	// List of score ids
	Scores []string `json:"scores,omitempty"`
}

type TraceWithFullDetails struct {
	// The unique identifier of a trace
	Id        string       `json:"id"`
	Timestamp time.Time    `json:"timestamp"`
	Name      *string      `json:"name,omitempty"`
	Input     *interface{} `json:"input,omitempty"`
	Output    *interface{} `json:"output,omitempty"`
	SessionId *string      `json:"sessionId,omitempty"`
	Release   *string      `json:"release,omitempty"`
	Version   *string      `json:"version,omitempty"`
	UserId    *string      `json:"userId,omitempty"`
	Metadata  *interface{} `json:"metadata,omitempty"`
	Tags      []string     `json:"tags,omitempty"`
	// Public traces are accessible via url without login
	Public       *bool          `json:"public,omitempty"`
	Observations []*Observation `json:"observations,omitempty"`
	Scores       []*Score       `json:"scores,omitempty"`
}

type Traces struct {
	Data []*TraceWithDetails `json:"data,omitempty"`
	Meta *UtilsMetaResponse  `json:"meta,omitempty"`
}

type UpdateEventBody struct {
	TraceId             *string           `json:"traceId,omitempty"`
	Name                *string           `json:"name,omitempty"`
	StartTime           *time.Time        `json:"startTime,omitempty"`
	Metadata            *interface{}      `json:"metadata,omitempty"`
	Input               *interface{}      `json:"input,omitempty"`
	Output              *interface{}      `json:"output,omitempty"`
	Level               *ObservationLevel `json:"level,omitempty"`
	StatusMessage       *string           `json:"statusMessage,omitempty"`
	ParentObservationId *string           `json:"parentObservationId,omitempty"`
	Version             *string           `json:"version,omitempty"`
	Id                  string            `json:"id"`
}

type UpdateGenerationBody struct {
	TraceId             *string              `json:"traceId,omitempty"`
	Name                *string              `json:"name,omitempty"`
	StartTime           *time.Time           `json:"startTime,omitempty"`
	Metadata            *interface{}         `json:"metadata,omitempty"`
	Input               *interface{}         `json:"input,omitempty"`
	Output              *interface{}         `json:"output,omitempty"`
	Level               *ObservationLevel    `json:"level,omitempty"`
	StatusMessage       *string              `json:"statusMessage,omitempty"`
	ParentObservationId *string              `json:"parentObservationId,omitempty"`
	Version             *string              `json:"version,omitempty"`
	Id                  string               `json:"id"`
	EndTime             *time.Time           `json:"endTime,omitempty"`
	CompletionStartTime *time.Time           `json:"completionStartTime,omitempty"`
	Model               *string              `json:"model,omitempty"`
	ModelParameters     map[string]*MapValue `json:"modelParameters,omitempty"`
	Usage               *IngestionUsage      `json:"usage,omitempty"`
	PromptName          *string              `json:"promptName,omitempty"`
	PromptVersion       *int                 `json:"promptVersion,omitempty"`
}

type UpdateGenerationEvent struct {
	Id        string                `json:"id"`
	Timestamp string                `json:"timestamp"`
	Metadata  interface{}           `json:"metadata,omitempty"`
	Body      *UpdateGenerationBody `json:"body,omitempty"`
}

type UpdateObservationEvent struct {
	Id        string           `json:"id"`
	Timestamp string           `json:"timestamp"`
	Metadata  interface{}      `json:"metadata,omitempty"`
	Body      *ObservationBody `json:"body,omitempty"`
}

type UpdateSpanBody struct {
	TraceId             *string           `json:"traceId,omitempty"`
	Name                *string           `json:"name,omitempty"`
	StartTime           *time.Time        `json:"startTime,omitempty"`
	Metadata            *interface{}      `json:"metadata,omitempty"`
	Input               *interface{}      `json:"input,omitempty"`
	Output              *interface{}      `json:"output,omitempty"`
	Level               *ObservationLevel `json:"level,omitempty"`
	StatusMessage       *string           `json:"statusMessage,omitempty"`
	ParentObservationId *string           `json:"parentObservationId,omitempty"`
	Version             *string           `json:"version,omitempty"`
	Id                  string            `json:"id"`
	EndTime             *time.Time        `json:"endTime,omitempty"`
}

type UpdateSpanEvent struct {
	Id        string          `json:"id"`
	Timestamp string          `json:"timestamp"`
	Metadata  interface{}     `json:"metadata,omitempty"`
	Body      *UpdateSpanBody `json:"body,omitempty"`
}

type Usage struct {
	Input  *int            `json:"input,omitempty"`
	Output *int            `json:"output,omitempty"`
	Total  *int            `json:"total,omitempty"`
	Unit   *ModelUsageUnit `json:"unit,omitempty"`
}

type UtilsMetaResponse struct {
	// current page number
	Page int `json:"page"`
	// number of items per page
	Limit int `json:"limit"`
	// number of total items given the current filters/selection (if any)
	TotalItems int `json:"totalItems"`
	// number of total pages given the current limit
	TotalPages int `json:"totalPages"`
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package langfuse_test

import (
	"context"
	"github.com/wepala/langfuse-go/langfuse"
	"sync"
)

// Ensure, that EventManagerMock does implement langfuse.EventManager.
// If this is not the case, regenerate this file with moq.
var _ langfuse.EventManager = &EventManagerMock{}

// EventManagerMock is a mock implementation of langfuse.EventManager.
//
//	func TestSomethingThatUsesEventManager(t *testing.T) {
//
//		// make and configure a mocked langfuse.EventManager
//		mockedEventManager := &EventManagerMock{
//			EnqueueFunc: func(id string, eventType string, event interface{}) error {
//				panic("mock out the Enqueue method")
//			},
//			FlushFunc: func(ctxt context.Context)  {
//				panic("mock out the Flush method")
//			},
//		}
//
//		// use mockedEventManager in code that requires langfuse.EventManager
//		// and then make assertions.
//
//	}
type EventManagerMock struct {
	// EnqueueFunc mocks the Enqueue method.
	EnqueueFunc func(id string, eventType string, event interface{}) error

	// FlushFunc mocks the Flush method.
	FlushFunc func(ctxt context.Context)

	// calls tracks calls to the methods.
	calls struct {
		// Enqueue holds details about calls to the Enqueue method.
		Enqueue []struct {
			// ID is the id argument value.
			ID string
			// EventType is the eventType argument value.
			EventType string
			// Event is the event argument value.
			Event interface{}
		}
		// Flush holds details about calls to the Flush method.
		Flush []struct {
			// Ctxt is the ctxt argument value.
			Ctxt context.Context
		}
	}
	lockEnqueue sync.RWMutex
	lockFlush   sync.RWMutex
}

// Enqueue calls EnqueueFunc.
func (mock *EventManagerMock) Enqueue(id string, eventType string, event interface{}) error {
	if mock.EnqueueFunc == nil {
		panic("EventManagerMock.EnqueueFunc: method is nil but EventManager.Enqueue was just called")
	}
	callInfo := struct {
		ID        string
		EventType string
		Event     interface{}
	}{
		ID:        id,
		EventType: eventType,
		Event:     event,
	}
	mock.lockEnqueue.Lock()
	mock.calls.Enqueue = append(mock.calls.Enqueue, callInfo)
	mock.lockEnqueue.Unlock()
	return mock.EnqueueFunc(id, eventType, event)
}

// EnqueueCalls gets all the calls that were made to Enqueue.
// Check the length with:
//
//	len(mockedEventManager.EnqueueCalls())
func (mock *EventManagerMock) EnqueueCalls() []struct {
	ID        string
	EventType string
	Event     interface{}
} {
	var calls []struct {
		ID        string
		EventType string
		Event     interface{}
	}
	mock.lockEnqueue.RLock()
	calls = mock.calls.Enqueue
	mock.lockEnqueue.RUnlock()
	return calls
}

// Flush calls FlushFunc.
func (mock *EventManagerMock) Flush(ctxt context.Context) {
	if mock.FlushFunc == nil {
		panic("EventManagerMock.FlushFunc: method is nil but EventManager.Flush was just called")
	}
	callInfo := struct {
		Ctxt context.Context
	}{
		Ctxt: ctxt,
	}
	mock.lockFlush.Lock()
	mock.calls.Flush = append(mock.calls.Flush, callInfo)
	mock.lockFlush.Unlock()
	mock.FlushFunc(ctxt)
}

// FlushCalls gets all the calls that were made to Flush.
// Check the length with:
//
//	len(mockedEventManager.FlushCalls())
func (mock *EventManagerMock) FlushCalls() []struct {
	Ctxt context.Context
} {
	var calls []struct {
		Ctxt context.Context
	}
	mock.lockFlush.RLock()
	calls = mock.calls.Flush
	mock.lockFlush.RUnlock()
	return calls
}
